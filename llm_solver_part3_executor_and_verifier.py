
ARC Prize LLM Solver - Part 3: Executor & Verifier
====================================================

This script provides the components to execute and verify the DSL programs
generated by the LLM.

1.  DSLExecutor: Contains the actual implementation of the DSL functions.
    It takes a program (list of function calls) and applies it to a grid.

2.  ProgramVerifier: Uses the DSLExecutor to check if a candidate program
    correctly solves all training pairs for a given task.
"""

import numpy as np
from typing import List, Dict, Any, Tuple
import ast

# In a real notebook, the previous classes would be in prior cells.
# For this script, we assume they are available.
# We will re-define the necessary GridUtils functions from the hybrid solver for now.

class GridUtils:
    """Basic grid utilities needed by the executor."""
    @staticmethod
    def most_common_color(g: np.ndarray) -> int:
        if g.size == 0: return 0
        return int(np.bincount(g.flatten()).argmax())

class DSLExecutor:
    """
    Implements and executes the functions defined in the DSL.
    This is a direct, runnable implementation of the DSL definition.
    """

    def execute_program(self, grid: np.ndarray, program: List[Tuple]) -> np.ndarray:
        """Executes a DSL program on a given grid."""
        current_grid = grid.copy()
        for func_name, params in program:
            method = getattr(self, func_name, None)
            if not method:
                raise ValueError(f"DSL function '{func_name}' not found.")
            current_grid = method(current_grid, **params)
        return current_grid

    # --- DSL Function Implementations ---

    def rotate(self, grid: np.ndarray, degrees: int) -> np.ndarray:
        if degrees not in [90, 180, 270]: raise ValueError("Invalid rotation degrees.")
        k = degrees // 90
        return np.rot90(grid, k=-k)

    def flip(self, grid: np.ndarray, axis: str) -> np.ndarray:
        if axis == 'h': return np.fliplr(grid)
        if axis == 'v': return np.flipud(grid)
        raise ValueError("Invalid flip axis.")

    def transpose(self, grid: np.ndarray) -> np.ndarray:
        return grid.T

    def tile_scale(self, grid: np.ndarray, height_ratio: int, width_ratio: int) -> np.ndarray:
        return np.kron(grid, np.ones((height_ratio, width_ratio), dtype=grid.dtype))

    def block_reduce(self, grid: np.ndarray, height_ratio: int, width_ratio: int) -> np.ndarray:
        h, w = grid.shape
        if h % height_ratio != 0 or w % width_ratio != 0: return grid
        th, tw = h // height_ratio, w // width_ratio
        out = np.zeros((th, tw), dtype=grid.dtype)
        for r in range(th):
            for c in range(tw):
                block = grid[r*height_ratio:(r+1)*height_ratio, c*width_ratio:(c+1)*width_ratio]
                out[r, c] = GridUtils.most_common_color(block)
        return out

    def crop_to_content(self, grid: np.ndarray, background: int = 0) -> np.ndarray:
        mask = grid != background
        if not mask.any(): return np.array([[background]], dtype=grid.dtype)
        rows, cols = np.where(mask)
        return grid[rows.min():rows.max()+1, cols.min():cols.max()+1]

    def pad_to_size(self, grid: np.ndarray, height: int, width: int, fill_color: int) -> np.ndarray:
        h, w = grid.shape
        out = np.full((height, width), fill_color, dtype=grid.dtype)
        h_offset, w_offset = (height - h) // 2, (width - w) // 2
        out[h_offset:h_offset+h, w_offset:w_offset+w] = grid
        return out

    def add_border(self, grid: np.ndarray, thickness: int, color: int) -> np.ndarray:
        return np.pad(grid, pad_width=thickness, mode='constant', constant_values=color)

    def remove_border(self, grid: np.ndarray, thickness: int) -> np.ndarray:
        return grid[thickness:-thickness, thickness:-thickness]

    def recolor(self, grid: np.ndarray, color_map: dict) -> np.ndarray:
        out = grid.copy()
        for k, v in color_map.items():
            out[grid == k] = v
        return out
    
    # NOTE: Object-centric functions would require more complex implementations
    # involving connected components analysis (flood fill), which we omit here for brevity
    # but would be included in the full solver.
    def keep_largest_object(self, grid: np.ndarray, fill_color: int) -> np.ndarray:
        # Placeholder - a real implementation would use flood-fill
        print("Warning: `keep_largest_object` is a placeholder.")
        return grid 

    def crop_to_largest_object(self, grid: np.ndarray) -> np.ndarray:
        # Placeholder
        print("Warning: `crop_to_largest_object` is a placeholder.")
        return grid

    def translate(self, grid: np.ndarray, dy: int, dx: int, fill_color: int) -> np.ndarray:
        out = np.full_like(grid, fill_color)
        h, w = grid.shape
        src_r_start, src_r_end = max(0, -dy), min(h, h - dy)
        src_c_start, src_c_end = max(0, -dx), min(w, w - dx)
        dst_r_start, dst_r_end = max(0, dy), min(h, h + dy)
        dst_c_start, dst_c_end = max(0, dx), min(w, w + dx)
        out[dst_r_start:dst_r_end, dst_c_start:dst_c_end] = \
            grid[src_r_start:src_r_end, src_c_start:src_c_end]
        return out

    def symmetrize(self, grid: np.ndarray, axis: str) -> np.ndarray:
        h, w = grid.shape
        out = grid.copy()
        if axis == 'h': out[h - h//2:] = out[:h//2][::-1]
        elif axis == 'v': out[:, w - w//2:] = out[:, :w//2][:, ::-1]
        return out

class ProgramVerifier:
    """
    Verifies a DSL program against a set of training examples.
    """
    def __init__(self):
        self.executor = DSLExecutor()

    def verify(self, program_str: str, train_examples: List[Dict]) -> bool:
        """
        Safely parses and verifies a program string from the LLM.

        Returns:
            True if the program correctly transforms all training examples, False otherwise.
        """
        try:
            # Safely parse the LLM's string output into a Python object
            program = ast.literal_eval(program_str)
            if not isinstance(program, list):
                print(f"Error: LLM output is not a list: {program_str}")
                return False
        except (ValueError, SyntaxError) as e:
            print(f"Error parsing LLM output: {e}")
            return False

        try:
            for pair in train_examples:
                input_grid = np.array(pair['input'])
                expected_output_grid = np.array(pair['output'])
                
                # Execute the program on the input grid
                predicted_grid = self.executor.execute_program(input_grid, program)
                
                # Check if the prediction matches the expectation
                if not np.array_equal(predicted_grid, expected_output_grid):
                    return False # Verification failed for this pair
            
            # If all pairs passed, verification is successful
            return True
        except (ValueError, TypeError, KeyError) as e:
            print(f"Error during program execution: {e}")
            return False

# Example of how to use these classes
if __name__ == '__main__':
    # 1. Define a sample ARC task
    sample_task = {
        "train": [
            {
                "input": [[1, 2, 0], [3, 4, 0]],
                "output": [[0, 8, 7], [0, 6, 5]]
            }
        ]
    }

    # 2. Simulate two different program outputs from an LLM
    # This program correctly flips and recolors the grid.
    correct_program_str = '[("flip", {"axis": "h"}), ("recolor", {"color_map": {1:7, 2:8, 3:5, 4:6}})]'
    
    # This program only does the flip, so it's incorrect.
    incorrect_program_str = '[("flip", {"axis": "h"})]'